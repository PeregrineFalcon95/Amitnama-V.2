<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="Description" content="Author: Amit Sarker. Here we will learn to find the shortest cycle of a graph. We will solve Beehives form ICPC Live Archive. Then we will solve Cycle in Maze from Codeforces. Here we will find lexixographically smallest cycle of leangth K. We will learn multiple source Breadth First Search. Then we will solve Police Station problem from Codeforces.">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Breadth First Search (bfs) algorithm tutorials AmitNama programming blog</title>
    <link rel="stylesheet" href="styles_article.css">
</head>
<body>
    <nav>
        <a href="../../index.html">HOME</a>
        <a href="#" class="current">English</a>
        <a href="bfs_3_bangla.html">বাংলা</a>
        <a href="../../about me/about_me.html">About Me</a>  
    </nav>
    <div class="sidebar">
        <p class="blogName">AmitNama</p>
        <a href="../../beginner/beginner_index.html">Beginners Section</a>
        <a href="../graph_theory_index.html">Graph Theory</a>
        <a href="#">Data Structure</a>
        <a href="../../number theory/Number_Theory_index.html">Number Theory</a>
        <a href="#">Bit Manipulation</a>
        <a href="#">Dynamic Programming</a>
        <a href="#">Backtracking</a>
        <a href="#">Source Code of Videos</a>

    </div>

    <div class="container">
        <p class="heading">Breadth First Search (BFS) tutorials. Part: 3</p>
        
        <div class="card">
            <p class="card-title">Learning applications and solving Problems with BFS.</p>
            <p class="card-text">
                <a href="bfs_1.html" target="blank"><strong>Learn bfs from here!</strong></a> <br>
                <a href="bfs_2.html" target="blank"><strong>Part 2!</strong></a>
                <br> <br>
                <strong>Problem: </strong>
                You’re given an undirected, unweighted graph. You’ve to tell what is the length of the shortest cycle in this graph? Try to solve this yourself first.<br>
                <strong>Solution: </strong> It’s a very simple problem. We’ll run a bfs from each node. Suppose source node is <strong>s</strong>. Front node is <strong>a</strong> inside the bfs. And every adjacent node of node <strong>a</strong> is <strong>b</strong>. <br> While traversing the graph, every time we check for node <strong>b</strong>, we’ll also check if that node is already visited. If it is, there is a cycle in this graph. What is the length of this cycle? <br> Very simple! <br><br>
                <strong>Distance of a from s + distance of b from s + 1.</strong> <br><br>
                Why we’re adding plus 1? Because node <strong>a</strong> and node <strong>b</strong> is connected through an edge. <br> Anythins suspicious? <br> If you think so, you're right! While we'll check for node <strong>b</strong> from node <strong>a</strong> we've to check if node <strong>b</strong> is the parent of node <strong>a</strong>. Because its an undirected graph. <br> Now solve the following problem! <br> <br> <a href="https://icpcarchive.ecs.baylor.edu/external/61/6151.pdf" target="blank">6151 Beehives - ICPC Live Archive.</a> <br> 
                <a href="codes/6151_live.html" target="blank">Complete code with C++</a> <br>
                <br>
                <strong>Cycle In Maze.</strong> <br>
                <a href="https://codeforces.com/contest/769/problem/C" target="blank">Cycle In Maze Codeforces</a> Please read the problem.<br>
                You’re given a grid containing <strong>n*m</strong> cells and an integer <strong>k</strong>. Source cell is the cell containing a character <strong>X</strong>. You’ve to start and finish your journey in the source cell. Total path length have to be equal to <strong>k</strong>. You can visit a cell multiple times. If there are one or more such paths, you’ve to print the lexicographically minimal path or tell it is impossible to travel in such a way. <br>Now try to solve this yourself! <br><br>
                <strong>Solution: </strong> We can’t start and finish our journey in the same cell in a grid with an odd length path. First we’ll check if the value of <strong>k</strong> is odd. <br> How can we solve the rest? <br>
                Let’s find the shortest path for every cell from source cell and save them in the level array. <br>
                We’ve to find the lexicographically minimal path. So we’ll traverse the grid in <strong>D L R U</strong> order. Let’s change our direction array in following manner: <br> <br>
            </p>
            <pre>
int dx[]={+1,+0,+0,-1};
int dy[]={+0,-1,+1,+0};</pre>
            <p class="card-text">
                <br>
                We’ll traverse <strong>k</strong> times from one cell to another with a simple loop. We’ll try to move from our current cell using the direction array. We can move from one cell to other only if we can go back to the source node with the remaining moves. Which we can easily check using the level array. <br>That was the reason we implemented the bfs before. <br>Now I hope that you won’t have any trouble solving the problem! <br> <br> 
                <a href="codes/CycleInMaze.html" target="blank">Full code in C++</a>
                <br> <br>
                <strong>Police Stations.</strong> <br>
                <a href="https://codeforces.com/contest/796/problem/D" target="blank">Police Stations Codeforces.</a> Please read this problem. <br> <strong>Problem: </strong> You’re given a tree consists of <strong>n</strong> nodes. There are <strong>k</strong> police stations in this tree. We’ve to remove maximum number of edges in such a way that after the removals it is still possible to visit at least one police station from each node using maximum of <strong>d</strong> edges. <br>Please try to solve this yourself before moving below. <br> <br> <strong>Solution: </strong> What can be the simplest solution? Find the nearest police station for each node. Then remove every edges which are not in any path from every node to its nearest police station. How can we do that? <br> Run a bfs from each node and save the path to its nearest police station. Then iterate over the edges and check if it is a part of any path. But this solution will surely get us a TLE verdict. <br><br> So we will use <strong>Multiple Source Bfs</strong> to solve this problem! <br> Let’s push all the police stations to the queue as source. Make all of their level equal to 0. Then visit every node using bfs. For each node save their parent. Then check for the input edges which edges are not in any path from the nodes to their nearest police stations using the parent array.  <br>How can we be sure about the fact that for every node it is possible to reach to its nearest police station using maximum of <strong>d</strong> edges?  <br> It is possible to reach a police station using maximum of <strong>d</strong> edges for each node in the initial graph. So, while we’re running multiple source bfs, we’re visiting the nearest nodes for each police station because no node is visited twice. <br>Now solve this problem if you haven’t solved it yet! <br><br>

                <a href="codes/PoliceStations.html" target="blank"> Full code in C++</a><br><br>
                <strong>COVID-19 Outbreak.</strong> <br>
                <a href="https://toph.co/p/covid-19-outbreak" target="blank">COVID-19 Outbreak - Toph</a> Please read this problem. <br> <strong>Problem: </strong> You’re given a tree consist of <strong>n</strong> nodes. Node <strong>z</strong> is the capital of the tree. There are some food trucks in every node. Every edge has a capacity of how many trucks can pass this edge. <br>If you send trucks from every node towards node <strong>z</strong> in optimal way, how many trucks can be there in the end? Our goal is to maximize the number of trucks.<br>Try to solve it yourself first. <br><br>
                <strong>Solution: </strong> You can solve this problem easily using <a href="#" target="blank">Depth First Search</a>. But here we'll try to solve this using Breadth First Search. <br> Here every node is source node. Because we’ll send trucks from every nodes. We can use multiple source bfs to solve this problem! But in which order we’ll push the nodes in the queue? And how can we send those trucks? <br> We’ll push the farthest node from node <strong>z</strong> in the queue. Then the second farthest node and then the third farthest node and so on.........  <br> That means we’ll push the nodes in the queue according to the distance from the node <strong>z</strong>. Sorted according to farthest to shortest! <br>We are pushing the nodes before starting the bfs. So, we won’t push any nodes in the queue inside our bfs. <br>But how will we send those trucks?  <br><br>Suppose the initial flow for each node is the number of trucks each node has initially. While checking the adjacent nodes of the front node of the queue we’ll pass the maximum possible flow to the adjacent nodes by checking the limits and update the new flow. After finishing transferring flow the answer is the flow of node <strong>z</strong>! <br> Let's see the procedure step by step: <br><br><strong>1</strong>. Run a bfs from capital <strong>z</strong>. Save every node in a vector according to the distance from node <strong>z</strong>. <br><strong>2</strong>. We’ll push all the nodes from the sorted vector to queue. <br><strong>3</strong>. Let’s empty the queue. For every front node of the queue let’s check all of its adjacent nodes and pass the maximum possible flow by checking the limits. <br><br>In the end the flow of node <strong>z</strong> is the answer! <br> Hope that you won't have any problem to solve this problem!<br> <br>

                <a href="codes/COVID-19Outbreak.html" target="blank">Full code with C++.</a>
                <br><br>

                Some problems to practice: <br>
                <a href="https://www.spoj.com/problems/AKBAR/" target="blank">Akbar , The great - Spoj</a> 
                <br><br>
                <strong>KuPellaKeS:</strong><br>
                <a href="https://onlinejudge.org/external/109/10968.pdf" target="blank">KuPellaKeS </a>Please read the problem.<br>
                <br> <strong>Problem: </strong> You are given a graph consist of <strong>n</strong> nodes and <strong>m</strong> edges. Initially maximum two nodes can have odd number of degrees. We have to remove minimum number of nodes in such a way that after the removal every node should have even number of degrees and every node have some adjacent nodes. <br><br>
                <strong>Solution: </strong> It need some brainstorming to solve this problem. But once you find out the solution it’s easy. If the given graph already fulfill the requirements the answer is zero! Otherwise we’ve to find two nodes with odd number of degrees. Let’s assume they are node <strong>a</strong> and node <strong>b</strong>. Now we’ve to find the shortest path from <strong>a</strong> to <strong>b</strong> that every node in that shortest path have more than two edges.  And the answer will be the length of that path. If there are no such path the answer will be impossible. <br> <br>
                <a href="codes/KuPellaKeS.html" target="blank">Full code with C++.</a> <br> <br>

                Some problems to practice: <br>
                <a href="https://www.spoj.com/problems/AKBAR/" target="blank">Akbar , The great - Spoj</a> <br> <a href="http://uva.onlinejudge.org/external/109/10977.pdf" target="blank">10977 - Enchanted Forest (Uva) Online Judge.</a> <br> <a href="http://uva.onlinejudge.org/external/113/11352.pdf" target="blank">  11352 - Crazy King (Uva) Online Judge.</a> <br> <a href="https://codeforces.com/gym/102411/problem/E" target="blank">Equidistant Codeforces</a> <br>
                <a href="https://codeforces.com/contest/35/problem/C" target="blank">Fire Again - Codeforces</a> <br>
                <a href="https://www.spoj.com/problems/SERGRID/" target="blank">Grid - Spoj</a>
                <br><br> 
                <a href="bfs_4.html"><strong>Start Reading Part 4!</strong></a>
                <br>
            </p>

            
        </div>
        
    </div>

    <footer>
        <p>Copyright 2020© Amit Sarker</p>
    </footer>
   
</body>
</html>